module ActionMailbox
  extend ActiveSupport::Autoload
end

module ActionMailbox
  # The base class for all application mailboxes. Not intended to be inherited from directly. Inherit from
  # +ApplicationMailbox+ instead, as that's where the app-specific routing is configured. This routing
  # is specified in the following ways:
  #
  #   class ApplicationMailbox < ActionMailbox::Base
  #     # Any of the recipients of the mail (whether to, cc, bcc) are matched against the regexp.
  #     routing /^replies@/i => :replies
  #
  #     # Any of the recipients of the mail (whether to, cc, bcc) needs to be an exact match for the string.
  #     routing "help@example.com" => :help
  #
  #     # Any callable (proc, lambda, etc) object is passed the inbound_email record and is a match if true.
  #     routing ->(inbound_email) { inbound_email.mail.to.size > 2 } => :multiple_recipients
  #
  #     # Any object responding to #match? is called with the inbound_email record as an argument. Match if true.
  #     routing CustomAddress.new => :custom
  #
  #     # Any inbound_email that has not been already matched will be sent to the BackstopMailbox.
  #     routing :all => :backstop
  #   end
  #
  # Application mailboxes need to overwrite the +#process+ method, which is invoked by the framework after
  # callbacks have been run. The callbacks available are: +before_processing+, +after_processing+, and
  # +around_processing+. The primary use case is ensure certain preconditions to processing are fulfilled
  # using +before_processing+ callbacks.
  #
  # If a precondition fails to be met, you can halt the processing using the +#bounced!+ method,
  # which will silently prevent any further processing, but not actually send out any bounce notice. You
  # can also pair this behavior with the invocation of an Action Mailer class responsible for sending out
  # an actual bounce email. This is done using the +#bounce_with+ method, which takes the mail object returned
  # by an Action Mailer method, like so:
  #
  #   class ForwardsMailbox < ApplicationMailbox
  #     before_processing :ensure_sender_is_a_user
  #
  #     private
  #       def ensure_sender_is_a_user
  #         unless User.exist?(email_address: mail.from)
  #           bounce_with UserRequiredMailer.missing(inbound_email)
  #         end
  #       end
  #   end
  #
  # During the processing of the inbound email, the status will be tracked. Before processing begins,
  # the email will normally have the +pending+ status. Once processing begins, just before callbacks
  # and the +#process+ method is called, the status is changed to +processing+. If processing is allowed to
  # complete, the status is changed to +delivered+. If a bounce is triggered, then +bounced+. If an unhandled
  # exception is bubbled up, then +failed+.
  #
  # Exceptions can be handled at the class level using the familiar +Rescuable+ approach:
  #
  #   class ForwardsMailbox < ApplicationMailbox
  #     rescue_from(ApplicationSpecificVerificationError) { bounced! }
  #   end
  class Base
    include ActiveSupport::Rescuable

    include ActionMailbox::Callbacks

    include ActionMailbox::Routing

    attr_reader inbound_email: untyped

    def self.receive: (untyped inbound_email) -> untyped

    def initialize: (untyped inbound_email) -> void

    def perform_processing: () -> untyped

    def process: () -> nil

    def finished_processing?: () -> untyped

    # Enqueues the given +message+ for delivery and changes the inbound email's status to +:bounced+.
    def bounce_with: (untyped message) -> untyped

    private

    def track_status_of_inbound_email: () { () -> untyped } -> untyped
  end
end

module ActionMailbox
  # Defines the callbacks related to processing.
  module Callbacks
    extend ActiveSupport::Concern

    include ActiveSupport::Callbacks

    TERMINATOR: untyped

    def before_processing: (*untyped methods) { () -> untyped } -> untyped

    def after_processing: (*untyped methods) { () -> untyped } -> untyped

    def around_processing: (*untyped methods) { () -> untyped } -> untyped
  end
end

module ActionMailbox
  class Engine < Rails::Engine
  end
end

module ActionMailbox
  # Returns the currently-loaded version of Action Mailbox as a <tt>Gem::Version</tt>.
  def self.gem_version: () -> untyped

  module VERSION
    MAJOR: ::Integer

    MINOR: ::Integer

    TINY: ::Integer

    PRE: ::String

    STRING: untyped
  end
end

module Mail
  class Address
    def ==: (untyped other_address) -> untyped
  end
end

module Mail
  class Address
    def self.wrap: (untyped address) -> untyped
  end
end

module Mail
  class Message
    def from_address: () -> untyped

    def recipients_addresses: () -> untyped

    def to_addresses: () -> untyped

    def cc_addresses: () -> untyped

    def bcc_addresses: () -> untyped

    def x_original_to_addresses: () -> untyped
  end
end

module Mail
  def self.from_source: (untyped source) -> untyped
end

module Mail
  class Message
    def recipients: () -> untyped
  end
end

module ActionMailbox
  class Relayer
    class Result
      def success?: () -> untyped

      def failure?: () -> untyped

      def transient_failure?: () -> untyped

      def permanent_failure?: () -> untyped
    end

    CONTENT_TYPE: ::String

    USER_AGENT: ::String

    attr_reader uri: untyped

    attr_reader username: untyped

    attr_reader password: untyped

    def initialize: (url: untyped url, password: untyped password, ?username: ::String username) -> void

    def relay: (untyped source) -> untyped

    private

    def post: (untyped source) -> untyped

    def client: () -> untyped
  end
end

module ActionMailbox
  # Encapsulates the routes that live on the ApplicationMailbox and performs the actual routing when
  # an inbound_email is received.
  class Router
    class RoutingError < StandardError
    end

    def initialize: () -> void

    def add_routes: (untyped routes) -> untyped

    def add_route: (untyped address, to: untyped to) -> untyped

    def route: (untyped inbound_email) -> untyped

    def mailbox_for: (untyped inbound_email) -> untyped

    private

    attr_reader routes: untyped
  end
end

module ActionMailbox
  # Encapsulates a route, which can then be matched against an inbound_email and provide a lookup of the matching
  # mailbox class. See examples for the different route addresses and how to use them in the +ActionMailbox::Base+
  # documentation.
  class Router::Route
    attr_reader address: untyped

    attr_reader mailbox_name: untyped

    def initialize: (untyped address, to: untyped to) -> void

    def match?: (untyped inbound_email) -> untyped

    def mailbox_class: () -> untyped

    private

    def ensure_valid_address: () -> untyped
  end
end

module ActionMailbox
  # See +ActionMailbox::Base+ for how to specify routing.
  module Routing
    extend ActiveSupport::Concern

    def routing: (untyped routes) -> untyped

    def route: (untyped inbound_email) -> untyped

    def mailbox_for: (untyped inbound_email) -> untyped
  end
end

module ActionMailbox
  class TestCase < ActiveSupport::TestCase
    include ActionMailbox::TestHelper
  end
end

module ActionMailbox
  module TestHelper
    # Create an +InboundEmail+ record using an eml fixture in the format of message/rfc822
    # referenced with +fixture_name+ located in +test/fixtures/files/fixture_name+.
    def create_inbound_email_from_fixture: (untyped fixture_name, ?status: ::Symbol status) -> untyped

    # Creates an +InboundEmail+ by specifying through options or a block.
    #
    # ==== Options
    #
    # * <tt>:status</tt> - The +status+ to set for the created +InboundEmail+.
    #   For possible statuses, see {its documentation}[rdoc-ref:ActionMailbox::InboundEmail].
    #
    # ==== Creating a simple email
    #
    # When you only need to set basic fields like +from+, +to+, +subject+, and
    # +body+, you can pass them directly as options.
    #
    #   create_inbound_email_from_mail(from: "david@loudthinking.com", subject: "Hello!")
    #
    # ==== Creating a multi-part email
    #
    # When you need to create a more intricate email, like a multi-part email
    # that contains both a plaintext version and an HTML version, you can pass a
    # block.
    #
    #   create_inbound_email_from_mail do
    #     to "David Heinemeier Hansson <david@loudthinking.com>"
    #     from "Bilbo Baggins <bilbo@bagend.com>"
    #     subject "Come down to the Shire!"
    #
    #     text_part do
    #       body "Please join us for a party at Bag End"
    #     end
    #
    #     html_part do
    #       body "<h1>Please join us for a party at Bag End</h1>"
    #     end
    #   end
    #
    # As with +Mail.new+, you can also use a block parameter to define the parts
    # of the message:
    #
    #   create_inbound_email_from_mail do |mail|
    #     mail.to "David Heinemeier Hansson <david@loudthinking.com>"
    #     mail.from "Bilbo Baggins <bilbo@bagend.com>"
    #     mail.subject "Come down to the Shire!"
    #
    #     mail.text_part do |part|
    #       part.body "Please join us for a party at Bag End"
    #     end
    #
    #     mail.html_part do |part|
    #       part.body "<h1>Please join us for a party at Bag End</h1>"
    #     end
    #   end
    def create_inbound_email_from_mail: (?status: ::Symbol status, **untyped mail_options) { () -> untyped } -> untyped

    # Create an +InboundEmail+ using the raw rfc822 +source+ as text.
    def create_inbound_email_from_source: (untyped source, ?status: ::Symbol status) -> untyped

    # Create an +InboundEmail+ from fixture using the same arguments as +create_inbound_email_from_fixture+
    # and immediately route it to processing.
    def receive_inbound_email_from_fixture: (*untyped args) -> untyped

    # Create an +InboundEmail+ using the same options or block as
    # {create_inbound_email_from_mail}[rdoc-ref:#create_inbound_email_from_mail],
    # then immediately route it for processing.
    def receive_inbound_email_from_mail: (**untyped kwargs) { () -> untyped } -> untyped

    # Create an +InboundEmail+ using the same arguments as +create_inbound_email_from_source+ and immediately route it
    # to processing.
    def receive_inbound_email_from_source: (*untyped args) -> untyped
  end
end

module ActionMailbox
  # Returns the currently-loaded version of Action Mailbox as a <tt>Gem::Version</tt>.
  def self.version: () -> untyped
end

module ActionMailbox
  module Generators
    class InstallGenerator < ::Rails::Generators::Base
      def create_action_mailbox_files: () -> untyped

      def add_action_mailbox_production_environment_config: () -> untyped

      def create_migrations: () -> untyped
    end
  end
end

module Rails
  module Generators
    class MailboxGenerator < NamedBase
      def create_mailbox_file: () -> untyped

      private

      def file_name: () -> untyped

      def application_mailbox_file_name: () -> "app/mailboxes/application_mailbox.rb"
    end
  end
end

module TestUnit
  module Generators
    class MailboxGenerator < ::Rails::Generators::NamedBase
      def create_test_files: () -> untyped

      private

      def file_name: () -> untyped
    end
  end
end
