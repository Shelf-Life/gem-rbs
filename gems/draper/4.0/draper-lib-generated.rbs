module Draper
  module AutomaticDelegation
    extend ActiveSupport::Concern

    # Delegates missing instance methods to the source object. Note: This will delegate `super`
    # method calls to `object` as well. Calling `super` will first try to call the method on
    # the parent decorator class. If no method exists on the parent class, it will then try
    # to call the method on the `object`.
    def method_missing: (untyped method, *untyped args) { () -> untyped } -> untyped

    # Checks if the decorator responds to an instance method, or is able to
    # proxy it to the source object.
    def respond_to_missing?: (untyped method, ?bool include_private) -> untyped

    private

    # @private
    def delegatable?: (untyped method) -> (nil | untyped)

    public

    module ClassMethods
      # Proxies missing class methods to the source class.
      def method_missing: (untyped method, *untyped args) { () -> untyped } -> untyped

      # Checks if the decorator responds to a class method, or is able to proxy
      # it to the source class.
      def respond_to_missing?: (untyped method, ?bool include_private) -> untyped

      # @private
      def delegatable?: (untyped method) -> untyped

      # @private
      # Avoids reloading the model class when ActiveSupport clears autoloaded
      # dependencies in development mode.
      def before_remove_const: () -> nil
    end
  end
end

module Draper
  class CollectionDecorator
    include Draper::ViewHelpers

    include Draper::QueryMethods

    extend Draper::Delegation

    # @return the collection being decorated.
    attr_reader object: untyped

    # @return [Class] the decorator class used to decorate each item, as set by
    #   {#initialize}.
    attr_reader decorator_class: untyped

    # @return [Hash] extra data to be used in user-defined methods, and passed
    #   to each item's decorator.
    attr_accessor context: untyped

    # @param [Enumerable] object
    #   collection to decorate.
    # @option options [Class, nil] :with (nil)
    #   the decorator class used to decorate each item. When `nil`, each item's
    #   {Decoratable#decorate decorate} method will be used.
    # @option options [Hash] :context ({})
    #   extra data to be stored in the collection decorator and used in
    #   user-defined methods, and passed to each item's decorator.
    def initialize: (untyped object, ?::Hash[untyped, untyped] options) -> void

    alias self.decorate self.new

    # @return [Array] the decorated items.
    def decorated_collection: () -> untyped

    def to_s: () -> ::String

    # @return [true]
    def decorated?: () -> ::TrueClass

    alias decorated_with? instance_of?

    def kind_of?: (untyped klass) -> untyped

    alias is_a? kind_of?

    def replace: (untyped other) -> untyped

    # Decorates the given item.
    def decorate_item: (untyped item) -> untyped

    private

    def item_decorator: () -> untyped
  end
end

module Draper
  module Compatibility
    # Draper expects your `ApplicationController` to include `ActionView::Rendering`. The
    # `ApplicationController` generated by Rails 5 API-only applications (created with
    # `rails new --api`) don't by default. However, including `ActionView::Rendering` in
    # `ApplicatonController` breaks `render :json` due to `render_to_body` being overridden.
    #
    # This compatibility patch fixes the issue by restoring the original `render_to_body`
    # method after including `ActionView::Rendering`. Ultimately, including `ActionView::Rendering`
    # in an ActionController::API may not be supported functionality by Rails (see Rails issue
    # for more detail: https://github.com/rails/rails/issues/27211). This hack is meant to be a
    # temporary solution until we can find a way to not rely on the controller layer.
    module ApiOnly
      extend ActiveSupport::Concern

      alias previous_render_to_body render_to_body

      include ActionView::Rendering
    end
  end
end

module Draper
  module Configuration
    def configure: () { (untyped) -> untyped } -> untyped

    def default_controller: () -> untyped

    def default_controller=: (untyped controller) -> untyped

    def default_query_methods_strategy: () -> untyped

    def default_query_methods_strategy=: (untyped strategy) -> untyped
  end
end

module Draper
  # Provides shortcuts to decorate objects directly, so you can do
  # `@product.decorate` instead of `ProductDecorator.new(@product)`.
  #
  # This module is included by default into `ActiveRecord::Base` and
  # `Mongoid::Document`, but you're using another ORM, or want to decorate
  # plain old Ruby objects, you can include it manually.
  module Decoratable
    extend ActiveSupport::Concern

    include Draper::Decoratable::Equality

    # Decorates the object using the inferred {#decorator_class}.
    # @param [Hash] options
    #   see {Decorator#initialize}
    def decorate: (?::Hash[untyped, untyped] options) -> untyped

    # (see ClassMethods#decorator_class)
    def decorator_class: () -> untyped

    def decorator_class?: () -> untyped

    # The list of decorators that have been applied to the object.
    #
    # @return [Array<Class>] `[]`
    def applied_decorators: () -> ::Array[untyped]

    # (see Decorator#decorated_with?)
    # @return [false]
    def decorated_with?: (untyped decorator_class) -> ::FalseClass

    # Checks if this object is decorated.
    #
    # @return [false]
    def decorated?: () -> ::FalseClass

    module ClassMethods
      # Decorates a collection of objects. Used at the end of a scope chain.
      #
      # @example
      #   Product.popular.decorate
      # @param [Hash] options
      #   see {Decorator.decorate_collection}.
      def decorate: (?::Hash[untyped, untyped] options) -> untyped

      def decorator_class?: () -> untyped

      # Infers the decorator class to be used by {Decoratable#decorate} (e.g.
      # `Product` maps to `ProductDecorator`).
      #
      # @return [Class] the inferred decorator class.
      def decorator_class: (?untyped called_on) -> untyped

      # Compares with possibly-decorated objects.
      #
      # @return [Boolean]
      def ===: (untyped other) -> untyped
    end
  end
end

module Draper
  module Decoratable
    module Equality
      # Compares self with a possibly-decorated object.
      #
      # @return [Boolean]
      def ==: (untyped other) -> untyped

      # Compares an object to a possibly-decorated object.
      #
      # @return [Boolean]
      def self.test: (untyped object, untyped other) -> untyped

      # @private
      def self.test_for_decorator: (untyped object, untyped other) -> untyped
    end
  end
end

module Draper
  # @private
  class DecoratedAssociation
    def initialize: (untyped owner, untyped association, untyped options) -> void

    def call: () -> untyped

    private

    attr_reader factory: untyped

    attr_reader owner: untyped

    attr_reader association: untyped

    attr_reader scope: untyped

    def decorate: () -> untyped
  end
end

module Draper
  module DecoratesAssigned
    # @overload decorates_assigned(*variables, options = {})
    #   Defines a helper method to access decorated instance variables.
    #
    #   @example
    #     # app/controllers/articles_controller.rb
    #     class ArticlesController < ApplicationController
    #       decorates_assigned :article
    #
    #       def show
    #         @article = Article.find(params[:id])
    #       end
    #     end
    #
    #     # app/views/articles/show.html.erb
    #     <%= article.decorated_title %>
    #
    #   @param [Symbols*] variables
    #     names of the instance variables to decorate (without the `@`).
    #   @param [Hash] options
    #   @option options [Decorator, CollectionDecorator] :with (nil)
    #     decorator class to use. If nil, it is inferred from the instance
    #     variable.
    #   @option options [Hash, #call] :context
    #     extra data to be stored in the decorator. If a Proc is given, it will
    #     be passed the controller and should return a new context hash.
    def decorates_assigned: (*untyped variables) -> untyped
  end
end

module Draper
  class Decorator
    include Draper::ViewHelpers

    extend Draper::Delegation

    include ActiveModel::Serialization

    include ActiveModel::Serializers::JSON

    # @return the object being decorated.
    attr_reader object: untyped

    alias model object

    # @return [Hash] extra data to be used in user-defined methods.
    attr_accessor context: untyped

    # Wraps an object in a new instance of the decorator.
    #
    # Decorators may be applied to other decorators. However, applying a
    # decorator to an instance of itself will create a decorator with the same
    # source as the original, rather than redecorating the other instance.
    #
    # @param [Object] object
    #   object to decorate.
    # @option options [Hash] :context ({})
    #   extra data to be stored in the decorator and used in user-defined
    #   methods.
    def initialize: (untyped object, ?::Hash[untyped, untyped] options) -> void

    alias self.decorate self.new

    # Automatically delegates instance methods to the source object. Class
    # methods will be delegated to the {object_class}, if it is set.
    #
    # @return [void]
    def self.delegate_all: () -> untyped

    # Sets the source class corresponding to the decorator class.
    #
    # @note This is only necessary if you wish to proxy class methods to the
    #   source (including when using {decorates_finders}), and the source class
    #   cannot be inferred from the decorator class (e.g. `ProductDecorator`
    #   maps to `Product`).
    # @param [String, Symbol, Class] object_class
    #   source class (or class name) that corresponds to this decorator.
    # @return [void]
    def self.decorates: (untyped object_class) -> untyped

    # Returns the source class corresponding to the decorator class, as set by
    # {decorates}, or as inferred from the decorator class name (e.g.
    # `ProductDecorator` maps to `Product`).
    #
    # @return [Class] the source class that corresponds to this decorator.
    def self.object_class: () -> untyped

    # Checks whether this decorator class has a corresponding {object_class}.
    def self.object_class?: () -> untyped

    # Automatically decorates ActiveRecord finder methods, so that you can use
    # `ProductDecorator.find(id)` instead of
    # `ProductDecorator.decorate(Product.find(id))`.
    #
    # Finder methods are applied to the {object_class}.
    #
    # @return [void]
    def self.decorates_finders: () -> untyped

    # Automatically decorate an association.
    #
    # @param [Symbol] association
    #   name of the association to decorate (e.g. `:products`).
    # @option options [Class] :with
    #   the decorator to apply to the association.
    # @option options [Symbol] :scope
    #   a scope to apply when fetching the association.
    # @option options [Hash, #call] :context
    #   extra data to be stored in the associated decorator. If omitted, the
    #   associated decorator's context will be the same as the parent
    #   decorator's. If a Proc is given, it will be called with the parent's
    #   context and should return a new context hash for the association.
    # @return [void]
    def self.decorates_association: (untyped association, ?::Hash[untyped, untyped] options) -> untyped

    # @overload decorates_associations(*associations, options = {})
    #   Automatically decorate multiple associations.
    #   @param [Symbols*] associations
    #     names of the associations to decorate.
    #   @param [Hash] options
    #     see {decorates_association}.
    #   @return [void]
    def self.decorates_associations: (*untyped associations) -> untyped

    # Decorates a collection of objects. The class of the collection decorator
    # is inferred from the decorator class if possible (e.g. `ProductDecorator`
    # maps to `ProductsDecorator`), but otherwise defaults to
    # {Draper::CollectionDecorator}.
    #
    # @param [Object] object
    #   collection to decorate.
    # @option options [Class, nil] :with (self)
    #   the decorator class used to decorate each item. When `nil`, it is
    #   inferred from each item.
    # @option options [Hash] :context
    #   extra data to be stored in the collection decorator.
    def self.decorate_collection: (untyped object, ?::Hash[untyped, untyped] options) -> untyped

    # @return [Array<Class>] the list of decorators that have been applied to
    #   the object.
    def applied_decorators: () -> untyped

    # Checks if a given decorator has been applied to the object.
    #
    # @param [Class] decorator_class
    def decorated_with?: (untyped decorator_class) -> untyped

    # Checks if this object is decorated.
    #
    # @return [true]
    def decorated?: () -> ::TrueClass

    # Compares the source object with a possibly-decorated object.
    #
    # @return [Boolean]
    def ==: (untyped other) -> untyped

    # Delegates equality to :== as expected
    #
    # @return [Boolean]
    def eql?: (untyped other) -> untyped

    # Returns a unique hash for a decorated object based on
    # the decorator class and the object being decorated.
    #
    # @return [Fixnum]
    def hash: () -> untyped

    # Checks if `self.kind_of?(klass)` or `object.kind_of?(klass)`
    #
    # @param [Class] klass
    def kind_of?: (untyped klass) -> untyped

    alias is_a? kind_of?

    # Checks if `self.instance_of?(klass)` or `object.instance_of?(klass)`
    #
    # @param [Class] klass
    def instance_of?: (untyped klass) -> untyped

    # ActiveModel compatibility
    # @private
    def to_model: () -> untyped

    # @return [Hash] the object's attributes, sliced to only include those
    # implemented by the decorator.
    def attributes: () -> untyped

    # @return [Class] the class created by {decorate_collection}.
    def self.collection_decorator_class: () -> untyped

    private

    def self.inherited: (untyped subclass) -> untyped

    def self.alias_object_to_object_class_name: () -> untyped

    def self.object_class_name: () -> (nil | untyped)

    def self.inferred_object_class: () -> untyped

    def self.collection_decorator_name: () -> untyped

    def handle_multiple_decoration: (untyped options) -> untyped

    def decorated_associations: () -> untyped
  end
end

module Draper
  module Delegation
    # @overload delegate(*methods, options = {})
    #   Overrides {http://api.rubyonrails.org/classes/Module.html#method-i-delegate Module.delegate}
    #   to make `:object` the default delegation target.
    #
    #   @return [void]
    def delegate: (*untyped methods) -> untyped
  end
end

module Draper
  class Factory
    # Creates a decorator factory.
    #
    # @option options [Decorator, CollectionDecorator] :with (nil)
    #   decorator class to use. If nil, it is inferred from the object
    #   passed to {#decorate}.
    # @option options [Hash, #call] context
    #   extra data to be stored in created decorators. If a proc is given, it
    #   will be called each time {#decorate} is called and its return value
    #   will be used as the context.
    def initialize: (?::Hash[untyped, untyped] options) -> void

    # Decorates an object, inferring whether to create a singular or collection
    # decorator from the type of object passed.
    #
    # @param [Object] object
    #   object to decorate.
    # @option options [Hash] context
    #   extra data to be stored in the decorator. Overrides any context passed
    #   to the constructor.
    # @option options [Object, Array] context_args (nil)
    #   argument(s) to be passed to the context proc.
    # @return [Decorator, CollectionDecorator] the decorated object.
    def decorate: (untyped object, ?::Hash[untyped, untyped] options) -> (nil | untyped)

    private

    attr_reader decorator_class: untyped

    attr_reader default_options: untyped

    # @private
    class Worker
      def initialize: (untyped decorator_class, untyped object) -> void

      def call: (untyped options) -> untyped

      def decorator: () -> untyped

      private

      attr_reader decorator_class: untyped

      attr_reader object: untyped

      def object_decorator: () -> untyped

      def decorator_method: (untyped klass) -> untyped

      def collection?: () -> untyped

      def decoratable?: () -> untyped

      def update_context: (untyped options) -> untyped
    end
  end
end

module Draper
  # Provides automatically-decorated finder methods for your decorators. You
  # do not have to extend this module directly; it is extended by
  # {Decorator.decorates_finders}.
  module Finders
    def find: (untyped id, ?::Hash[untyped, untyped] options) -> untyped

    def all: (?::Hash[untyped, untyped] options) -> untyped

    def first: (?::Hash[untyped, untyped] options) -> untyped

    def last: (?::Hash[untyped, untyped] options) -> untyped

    # Decorates dynamic finder methods (`find_all_by_` and friends).
    def method_missing: (untyped method, *untyped args) { () -> untyped } -> untyped
  end
end

module Draper
  # Provides access to helper methods - both Rails built-in helpers, and those
  # defined in your application.
  class HelperProxy
    # @overload initialize(view_context)
    def initialize: (untyped view_context) -> void

    # Sends helper methods to the view context.
    def method_missing: (untyped method, *untyped args) { () -> untyped } -> untyped

    # Checks if the context responds to an instance method, or is able to
    # proxy it to the view context.
    def respond_to_missing?: (untyped method, ?bool include_private) -> untyped

    attr_reader view_context: untyped

    private

    def self.define_proxy: (untyped name) -> untyped
  end
end

module Draper::HelperSupport
  def decorate: (untyped input) { () -> untyped } -> untyped
end

module Draper
  # Include this module in your decorators to get direct access to the helpers
  # so that you can stop typing `h.` everywhere, at the cost of mixing in a
  # bazillion methods.
  module LazyHelpers
    # Sends missing methods to the {HelperProxy}.
    def method_missing: (untyped method, *untyped args) { () -> untyped } -> untyped
  end
end

module Draper
  module QueryMethods
    # Proxies missing query methods to the source class if the strategy allows.
    def method_missing: (untyped method, *untyped args) { () -> untyped } -> untyped

    def respond_to_missing?: (untyped method, ?bool include_private) -> untyped

    private

    # Configures the strategy used to proxy the query methods, which defaults to `:active_record`.
    def strategy: () -> untyped
  end
end

module Draper
  module QueryMethods
    module LoadStrategy
      def self.new: (untyped name) -> untyped

      class ActiveRecord
        def allowed?: (untyped method) -> untyped
      end

      class Mongoid
        def allowed?: (untyped method) -> untyped
      end
    end
  end
end

module ActiveModel
  class Railtie < Rails::Railtie
  end
end

module Draper
  class Railtie < Rails::Railtie
    def initialize_view_context: () -> untyped
  end
end

module Draper
  module DeviseHelper
    def sign_in: (untyped resource_or_scope, ?untyped? resource) -> untyped

    def sign_out: (untyped resource_or_scope) -> untyped

    private

    def _stub_current_scope: (untyped scope, untyped resource) -> untyped
  end
end


module Draper
  def self.undecorate: (untyped object) -> untyped

  def self.undecorate_chain: (untyped object) -> untyped
end

module Draper
  VERSION: ::String
end

module Draper
  module ViewContext
    # Hooks into a controller or mailer to save the view context in {current}.
    def view_context: () -> untyped

    # Set the current controller
    def activate_draper: () -> untyped

    # Returns the current controller.
    def self.controller: () -> untyped

    # Sets the current controller. Clears view context when we are setting
    # different controller.
    def self.controller=: (untyped controller) -> untyped

    # Returns the current view context, or builds one if none is saved.
    #
    # @return [HelperProxy]
    def self.current: () -> untyped

    # Sets the current view context.
    def self.current=: (untyped view_context) -> untyped

    # Clears the saved controller and view context.
    def self.clear!: () -> untyped

    # Builds a new view context for usage in tests. See {test_strategy} for
    # details of how the view context is built.
    def self.build: () -> untyped

    # Builds a new view context and sets it as the current view context.
    #
    # @return [HelperProxy]
    def self.build!: () -> untyped

    # Configures the strategy used to build view contexts in tests, which
    # defaults to `:full` if `test_strategy` has not been called. Evaluates
    # the block, if given, in the context of the view context's class.
    #
    # @example Pass a block to add helper methods to the view context:
    #   Draper::ViewContext.test_strategy :fast do
    #     include ApplicationHelper
    #   end
    #
    # @param [:full, :fast] name
    #   the strategy to use:
    #
    #   `:full` - build a fully-working view context. Your Rails environment
    #   must be loaded, including your `ApplicationController`.
    #
    #   `:fast` - build a minimal view context in tests, with no dependencies
    #   on other components of your application.
    def self.test_strategy: (untyped name) { () -> untyped } -> untyped

    # @private
    def self.build_strategy: () -> untyped
  end
end

module Draper
  module ViewContext
    # @private
    module BuildStrategy
      def self.new: (untyped name) { () -> untyped } -> untyped

      class Fast
        def initialize: () { () -> untyped } -> void

        def call: () -> untyped

        private

        attr_reader view_context_class: untyped
      end

      class Full
        def initialize: () { () -> untyped } -> void

        def call: () -> untyped

        private

        attr_reader block: untyped

        def controller: () -> untyped

        def new_test_request: (untyped controller) -> untyped

        def is_above_rails_5_1: () -> untyped
      end
    end
  end
end

module Draper
  # Provides the {#helpers} method used in {Decorator} and {CollectionDecorator}
  # to call the Rails helpers.
  module ViewHelpers
    extend ActiveSupport::Concern

    module ClassMethods
      # Access the helpers proxy to call built-in and user-defined
      # Rails helpers from a class context.
      #
      # @return [HelperProxy] the helpers proxy
      def helpers: () -> untyped

      alias h helpers
    end

    # Access the helpers proxy to call built-in and user-defined
    # Rails helpers. Aliased to `h` for convenience.
    #
    # @return [HelperProxy] the helpers proxy
    def helpers: () -> untyped

    alias h helpers

    # Alias for `helpers.localize`, since localize is something that's used
    # quite often. Further aliased to `l` for convenience.
    def localize: (*untyped args) -> untyped

    alias l localize
  end
end
