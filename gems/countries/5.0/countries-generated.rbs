module ISO3166
  attr_writer self.configuration: untyped

  def self.configuration: () -> untyped

  def self.reset: () -> untyped

  def self.configure: () { (untyped) -> untyped } -> untyped

  class Configuration
    attr_accessor locales: untyped

    attr_accessor loaded_locales: untyped

    def initialize: () -> void

    # Enables the integration with the {Money}[https://github.com/RubyMoney/money] gem
    #
    # Please note that it requires you to add "money" gem to your gemfile.
    #
    #   gem "money", "~> 6.9"
    #
    # *WARNING* if you have a top level class named +Money+ you will conflict with this gem.
    #
    # @example
    #   c = ISO3166::Country['us']
    #   c.currency.iso_code # => 'USD'
    #   c.currency.name # => 'United States Dollar'
    #   c.currency.symbol # => '$'
    def enable_currency_extension!: () -> untyped

    private

    def default_locales: () -> untyped
  end
end

module ISO3166
  class Country
    extend CountryClassMethods

    extend CountryFinderMethods

    include Emoji

    attr_reader data: untyped

    def initialize: (untyped country_data) -> void

    def valid?: () -> untyped

    def postal_code: -> untyped

    def postal_code_format: -> untyped

    def languages_official: -> untyped

    alias zip postal_code

    alias zip? postal_code

    alias postal_code? postal_code

    alias zip_format postal_code_format

    alias languages languages_official

    def ==: (untyped other) -> untyped

    def eql?: (untyped other) -> untyped

    def hash: () -> untyped

    def <=>: (untyped other) -> untyped

    #  +true+ if this Country has any Subdivisions.
    def subdivisions?: () -> untyped

    # @return [Array<ISO3166::Subdivision>] the list of subdivisions for this Country.
    def subdivisions: () -> untyped

    # @param locale [String] The locale to use for translations.
    # @return [Array<Array>] This Country's subdivision pairs of names and codes.
    def subdivision_names_with_codes: (?::String locale) -> untyped

    alias states subdivisions

    # +true+ if this country is a member of the European Union.
    def in_eu?: () -> untyped

    # +true+ if this country is a member of the European Economic Area.
    def in_eea?: () -> untyped

    # +true+ if this country is a member of the European Single Market.
    def in_esm?: () -> untyped

    def to_s: () -> untyped

    # @return [Array<String>] the list of names for this Country in all loaded locales.
    def translated_names: () -> untyped

    # @param locale [String] The locale to use for translations.
    # @return [String] the name of this Country in the selected locale.
    def translation: (?::String locale) -> untyped

    # @return [String] the “common name” of this Country in English.
    def common_name: () -> untyped

    # @return [Array<String>] TThe list of names for this Country, in this Country's locales.
    def local_names: () -> untyped

    # @return [String] The name for this Country, in this Country's locale.
    def local_name: () -> untyped

    private

    def reload: () -> untyped
  end
end

module ISO3166
  UNSEARCHABLE_METHODS: untyped

  def self.Country: (untyped country_data_or_country) -> untyped

  module CountryClassMethods
    def new: (untyped country_data) -> untyped

    def codes: () -> untyped

    def all: () { () -> untyped } -> untyped

    alias countries all

    def all_names_with_codes: (?::String locale) -> untyped

    def pluck: (*untyped attributes) -> untyped

    def all_translated: (?::String locale) -> untyped

    def translations: (?::String locale) -> untyped

    def subdivisions: (untyped alpha2) -> untyped

    def create_subdivisions: (untyped subdivision_data) -> untyped

    def strip_accents: (untyped string) -> untyped

    def subdivision_data: (untyped alpha2) -> untyped

    def subdivision_file_path: (untyped alpha2) -> untyped

    # Some methods like parse_value are expensive in that they
    # create a large number of objects internally. In order to reduce the
    # object creations and save the GC, we can cache them in an class instance
    # variable. This will make subsequent parses O(1) and will stop the
    # creation of new String object instances.
    #
    # NB: We only want to use this cache for values coming from the JSON
    # file or our own code, caching user-generated data could be dangerous
    # since the cache would continually grow.
    def cached: (untyped value) { () -> untyped } -> untyped
  end
end

module ISO3166
  # Optional extension which allows you to get back a +Money::Currency+ object with all the currency info.
  # This requires enabling the integration with the {Money}[https://github.com/RubyMoney/money] gem (See {ISO3166::Configuration#enable_currency_extension!})
  module CountryCurrencyMethods
    # @return [Money::Currency] The currency data for this Country's +currency_code+
    def currency: () -> untyped
  end
end

module ISO3166
  module Emoji
    CODE_POINTS: untyped

    # @return [String] the emoji flag for this country
    #
    # The emoji flag for this country, using Unicode Regional Indicator characters. e.g: "U+1F1FA U+1F1F8" for 🇺🇸
    def emoji_flag: () -> untyped
  end
end

module ISO3166
  module CountryFinderMethods
    FIND_BY_REGEX: untyped

    SEARCH_TERM_FILTER_REGEX: untyped

    def search: (untyped query) -> untyped

    def []: (untyped query) -> untyped

    def find_all_by: (untyped attribute, untyped val) -> untyped

    def method_missing: (untyped method_name, *untyped arguments) -> untyped

    def respond_to_missing?: (untyped method_name, ?bool include_private) -> untyped

    def find_by: (untyped attribute, untyped value, ?untyped? obj) -> untyped

    def parse_attributes: (untyped attribute, untyped val) -> ::Array[untyped]

    def parse_value: (untyped value) -> untyped

    def searchable_attribute?: (untyped attribute) -> untyped

    def searchable_attributes: () -> untyped
  end
end

module ISO3166
  # Handles building the in memory store of countries data
  class Data
    def initialize: (untyped alpha2) -> void

    def call: () -> untyped

    # Registers a new Country with custom data.
    # If you are overriding an existing country, this does not perform a deep merge so you will need to __bring in all data you wish to be available__.
    # Overriding an existing country will also remove it from the internal management of translations.
    def self.register: (untyped data) -> untyped

    # Removes a country from the loaded data
    def self.unregister: (untyped alpha2) -> untyped

    def self.cache: () -> untyped

    # Resets the loaded data and cache
    def self.reset: () -> untyped

    def self.codes: () -> untyped

    def self.update_cache: () -> untyped

    private

    def self.load_data!: () -> untyped

    def self.sync_translations!: () -> (nil | untyped)

    def self.synchronized: () { () -> untyped } -> untyped

    def self.use_mutex?: () -> ::TrueClass

    def self.load_required?: () -> untyped

    def self.loaded_codes: () -> untyped

    # Codes that we have translations for in dataset
    def self.internal_codes: () -> untyped

    def self.cache_flush_required?: () -> untyped

    def self.locales_to_load: () -> untyped

    def self.locales_to_remove: () -> untyped

    def self.requested_locales: () -> untyped

    def self.loaded_locales: () -> untyped

    def self.load_translations: (untyped locale) -> untyped

    def self.unload_translations: (untyped locale) -> untyped

    def self.load_cache: (untyped file_array) -> untyped

    def self.datafile_path: (untyped file_array) -> untyped

    def self.deep_stringify_keys: (untyped data) -> untyped
  end
end

# Some apps might not want to constantly call +ISO3166::Country+. This gem has a helper that can provide a Country class
#
# With global Country Helper enabled
#
#   c = Country['US']
#
# This will conflict with any existing Country constant
#
# To Use
#
#   gem 'countries', require: 'countries/global'
#
class Country < ISO3166::Country
end

module ISO3166
  class Country
    def mongoize: () -> untyped

    # Convert an +ISO3166::Country+ to the data that is stored by Mongoid.
    def self.mongoize: (untyped country) -> untyped

    # Get the object as it was stored with Mongoid, and instantiate an +ISO3166::Country+.
    def self.demongoize: (untyped alpha2) -> untyped

    # Convert an +ISO3166::Country+ to the data that is stored by Mongoid.
    def self.evolve: (untyped country) -> untyped

    private

    def self.valid_alpha2?: (untyped country) -> untyped
  end
end

# Support code to allow updating subdivision data from the Unicode CLDR repository
module Sources
  # Support code to allow updating subdivision data from the Unicode CLDR repository
  module CLDR
    # Downloads data from the Unicode CLDR repository
    module Downloader
      def self?.subdivisions: () -> untyped

      def self?.download_folder: (untyped `type`) -> untyped
    end
  end
end

module Sources
  module CLDR
    # Auxiliary Subdivision class to support loading Unicode CLDR data to update local files
    class Subdivision
      attr_reader xml: untyped

      attr_reader language_code: untyped

      def initialize: (language_code: untyped language_code, xml: untyped xml) -> void

      def text: () -> untyped

      def country_code: () -> untyped

      def code: () -> untyped

      def type: () -> untyped

      def to_h: () -> untyped
    end
  end
end

module Sources
  module CLDR
    # Updates local subdivision files with data from the Unicode CLDR repository
    class SubdivisionUpdater
      def call: () -> untyped

      def update_locale: (untyped file_path) -> untyped
    end
  end
end

module Sources
  # Support code to allow updating subdivision data from the Unicode CLDR repository
  module Local
    # Loader for locally-cached data, to allow merging Unicode CLDR data with existing local data
    class CachedLoader
      attr_reader klass: untyped

      def initialize: (untyped klass) -> void

      def from_cache: (untyped country_code) -> untyped

      def load: (untyped country_code) -> untyped

      def save: (untyped country_code, untyped data) -> untyped
    end
  end
end

module Sources
  module Local
    # Auxiliary Subdivision class to support loading the local subdivision data to be updated with Unicode CLDR data
    class Subdivision
      attr_reader code: untyped

      def initialize: (untyped code) -> void

      def load: () -> untyped

      def save: (untyped data) -> untyped

      def file_path: () -> ::String

      def self.load: (untyped code) -> untyped
    end
  end
end

module ISO3166
  DEFAULT_COUNTRY_HASH: untyped

  DEFAULT_SUBDIVISION_HASH: untyped
end

module ISO3166
  Subdivision: untyped
end

module ISO3166
  # Extend Country class with support for timezones. Requires the  {tzinfo}[https://github.com/tzinfo/tzinfo] gem
  #
  #   gem 'tzinfo'
  #
  module TimezoneExtensions
    # TODO: rename method to tz_country or something similar
    def timezones: () -> untyped
  end
end

module ISO3166
  # Extend the hash class to allow locale lookup fall back behavior
  #
  # E.g. if a country has translations for +pt+, and the user looks up +pt-br+ fallback
  # to +pt+ to prevent from showing nil values
  class Translations < Hash[untyped, untyped]
    def []: (untyped locale) -> untyped
  end
end

module Countries
  VERSION: untyped
end
